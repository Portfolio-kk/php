<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP</title>
    <style>
        .red {
            color: red;
        }

        .blue {
            color: blue;
        }

        .gray {
            color: rgb(120, 120, 120);
        }

        pre {
            font-size: 15px;
        }

        #toTop {
            position: fixed;
            bottom: 0;
            right: 0;
            background: rgba(0, 0, 0, .1);
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 50px;
        }

        #toTop a {
            display: block;
            color: #000;
            text-decoration: none;
        }

        #toc {
            max-width: 500px;
            border: 2px solid rgba(0, 0, 0, .1);
            margin: 2em auto;
        }

        .toc-title {
            color: #444;
            padding: .5em 1em;
        }

        .toc-container {
            padding: 1em !important;
            margin: 0 !important;
        }

        .toc-container,
        .toc-container ul {
            counter-reset: ul-counter;
            list-style: none;
        }

        .toc-container li a {
            display: flex;
            color: #444 !important;
        }

        .toc-container li a:before {
            counter-increment: ul-counter;
            content: counters(ul-counter, ".");
            color: dodgerblue;
            /* お好みの色 */
            padding-right: .5em;
            white-space: nowrap;
        }

        #toc .toc-title:after {
            content: '[ひらく]';
            margin-left: .5em;
        }

        #toc[open] .toc-title:after {
            content: '[とじる]';
        }
    </style>
</head>

<body>
    <h1>PHP</h1>
    <details id="toc" open>
        <summary class="toc-title">目次</summary>
    </details>
    <h2>ショートカット</h2>
    <ul>
        <li>⌘ J ：ターミナルを開く</li>
        <li>⌘ 1 ：ターミナル＞エディター</li>
        <li>⌘ T ：エディター＞ターミナル</li>
        <li>⌥ ¥ : バックスラッシュ(\)</li>
        <li>Control C : 無限ループを止める</li>
    </ul>
    <h2>Docker</h2>
    <ul>
        <li>
            <a href="https://docker.com">docker</a>
        </li>
        <li>Products > Docker Desktop > ダウンロード　＞　アプリケーションにコピー　＞　デスクトップのDockerを右クリック　取り外す</li>
        <li>アクセス許可　＞　Dockerが開く</li>
        <li>レッスンではDockerが起動している必要があるので、トップのメニューにくじらのアイコンがあるのを確認してから始める</li>
    </ul>
    <h2>PHP 環境</h2>
    <ul>
        <li><a href="https://php.net">PHP　公式</a></li>
        <li>ブラウザー　→　 Request →　サーバー(要求に対して返す　サーブしてくれる)</li>
        <li>ブラウザー　←　 Response ←　サーバー　【phpならコードを実行してからhtmlに返還して返す】</li>
        <li>Dockerの上でサーバーを起動　（他のPCでもDockerを入れてあれば動く）</li>
        <li>Dockerからのアクセス方法　localhost:8080番ポート</li>
        <li>BASIC_PHP_V3 をダウンロード　VSCodeで開く php docker-compose.yml は触らない！ workを編集＞サーバーに同期される</li>
        <li>ターミナルを起動　ディレクトリに移動</li>
        <li>docker-compose up -d</li>
    </ul>
    <h2>PHP</h2>
    <ul>
        <li>.index > .php</li>
        <li><a href="http://localhost:8080/index.php">http://localhost:8080/index.php PHP分割サイト</a></li>
        <li>
            <span class="red">&lt;?php</span> echo &apos;こんにちは！&apos;<span class="red">; ?&gt;</span>
        </li>
        <li>
            &lt;?php echo &apos;こんにちは！&apos; . date(&apos;l&apos;); ?&gt; // 今日の曜日
        </li>
        <li>$*** 変数が使える　htmlの外で宣言</li>
        <li>
            <span class="red">&lt;?php echo</span> $message; ?&gt; <br>
            <span class="red">&lt;?=</span> $message; ?&gt; // 同じ
        </li>
        <li><span class="red">mt_rand(1, 3);</span> // 1以上3以下のランダムな整数値を生成</li>
        <li>if elseif(else if) else jsと同じように使える</li>
        <li>$n = mt_rand(1, 2); <br>
            if ($n === 1) {メッセージ１} <br>
            elseif ($n === 2) {メッセージ１}
        </li>
        <li>値を埋め込む時には悪意のある書き換えが不可にする為に、
            実体参照文字に変換
            <br>
            <span class="red">htmlspecialchars($message, ENT_QUOTES, 'UTF-8');</span><br>
            オプション①変換したい文字　②’マークも変換してね　③文字コード
        </li>
    </ul>
    <h2>共通部品</h2>
    <ul>
        <li>index.php から　_header.php へカットして移し、
            <br>
            &lt;?php <span class="red">include(</span>&apos;_header.php&apos;<span class="red">)</span>; ?&gt;
        </li>
        <li>phpの閉じタグは、その下にhtmlがなければ省略！ファイル最後の空白文字が出力に影響する為</li>
        <li>ページのソースを表示　でエラーが確認できる</li>
        <li>title 共通コードを埋めたら、空文字でも指定しないとエラー</li>
    </ul>

    <h2>詳解PHP 【基礎文法編】</h2>
    <ul>
        <li>
            <h3>#01 PHPは動的サイト</h3>
            <p>ユーザーによって異なる名前に変更する等、見る人によって動的にサイトを書き換える。(PHP)</p>
            <p>いつ誰が見ても同じサイトは静的サイト(HTML)</p>
        </li>
        <li>
            <h3>#02ターミナル</h3>
            <p>php ***.php Enter</p>
            <p>ターミナルに出力しながら開発していく</p>
            <p>ターミナルをクリアするには　clear か　Control + L</p>
        </li>
        <li>
            <h3>#03 メッセージを表示</h3>
            <ul>
                <li>改行　<span class="red">. PHP_EOL</span> end of line</li>
                <li>エラー　<span class="red">Parse error</span>：解析エラー <span class="red">syntax error</span>：文法エラー　ファイル名と行数
                    ***.php on line *</li>
            </ul>
        </li>
        <li>
            <h3>#04 コメントアウト</h3>
            <ul>
                <li>//</li>
                <li><span class="red">#</span></li>
                <li>/* ~~~ */　複数行</li>
            </ul>
        </li>
        <li>
            <h3>#05 変数</h3>
            <ul>
                <li>変数　$*** = '~~~';</li>
                <li>代入　大文字小文字は区別される</li>
            </ul>
        </li>
        <li>
            <h3>#06 文字列の扱い</h3>
            <ul>
                <li>文中の ' を " に変更</li>
                <li><span class="red"> " を使った場合、直接変数を入れれる</span>jsでいうテンプレートリテラルっぽい使い方 しかも${}なし</li>
                <li> " の中で " を使いたい場合 バックスラッシュ \(⌥¥)でエスケープ</li>
                <li>その他エスケープ　\t tab \n 改行</li>
            </ul>
        </li>
        <li>
            <h3>#07 ヒアドキュメント</h3>

            <pre>
        $変数 = <span class="red">&lt;&lt;&lt;終端記号 改行</span>
        ~~~ (この間の改行や字下げを保つ)
        <span class="red">終端記号</span>;
        </pre>
            <ul>
                <li>
                    好きな名前をつけていい　今回はEOT (end of text)
                </li>
                <li>この間の文字は改行や字下げを保つ　pre のような仕様だが、
                    コードを字下げしても終端記号に合わせられる
                </li>
                <li><span class="red">終端記号の後は必ず改行</span>　コメントでも書いてはいけない</li>
                <li>終端記号を ' で囲う　変数が使えない　nowdoc ナウドキュメント</li>
                <li><span class="red">終端記号を " で囲う・または囲わない　変数が使える　heredoc ヒアドキュメント</span></li>
            </ul>
        </li>
        <li>
            <h3>#08 数値の計算</h3>
            <p>jsと同じ</p>
            <pre>
                echo 10 + 3 . PHP_EOL; // 13
                echo 10 - 3 . PHP_EOL; // 7
                echo 10 * 3 . PHP_EOL; // 30
                echo 10 / 3 . PHP_EOL; // 3.333...
                
                echo 10 % 3 . PHP_EOL; // 余り　1
                echo 10 ** 3 . PHP_EOL; // べき乗　1000
                
                echo 2 + 10 * 3 . PHP_EOL; // 優先度　32
                echo (2 + 10) * 3 . PHP_EOL; // ()優先度　36
                
                #数値っぽいものは数値と認識
                echo 2 + '3' . PHP_EOL; // 5
            </pre>
        </li>
        <li>
            <h3>#09 変数の計算</h3>
            <pre>
                $price = 500;
                // $price = $price + 100; // 600
                $price += 100; // 同じ意味 他の四則演算も

                $price++;
                $price--;
                echo $price . PHP_EOL;
            </pre>
        </li>
        <li>
            <h3>#10 定数</h3>
            <ul>
                <li>const <span class="red">AAA</span> = '~~~'; // <span class="red">定数は大文字で</span></li>
                <li><span class="red">define('AAA', '~~~');</span> // constと同じ結果だが、細かい違いがある</li>
            </ul>
        </li>
        <li>
            <h3>#11 データ型</h3>
            <ul>
                <li>文字列(string) : 'hello' "world"</li>
                <li>整数<span class="red">(int)</span> : 5 -20</li>
                <li><span class="red">浮動小数点数(float)</span> : 3.2 -1.8</li>
                <li>null</li>
                <li>真偽値(bool) : true false</li>
                <li>配列(array) : [5, 3, 8]</li>
                <li>オブジェクト(object) : new Object()</li>
            </ul>
        </li>
        <li>
            <h3>#12 変数の型を調べる</h3>
            <span class="red">var_dumo(***);</span> jsの console.log(typeof ***)
            <pre>

                $a = 'hello';
                var_dump($a); // string(5) "hello"

                $b = 10;
                var_dump($b); // int(10)

                $c = -1.3;
                var_dump($c); // float(-1.3)

                $d = null;
                var_dump($d); // NULL

                $e = true;
                var_dump($e); // bool(true)

                #型を変換する キャスト
                $a = (float)10;
                var_dump($a);
            </pre>
        </li>

        <h2>構文</h2>
        <li>
            <h3>if文</h3>
            <pre>
                $score = 85;
                $score = 70;
                $score = 40;

                if ($score >= 80) {
                    echo 'Great!' . PHP_EOL;
                } else if ($score >= 60) {
                    echo 'Good!' . PHP_EOL;
                } else {
                    echo 'OK!' . PHP_EOL;
                }
            </pre>
            <p>セミコロン不要</p>
            <p>条件式は真偽値として評価 trueで実行</p>
            <h4>falseと評価される値</h4>
            <ul>
                <li>false</li>
                <li>±0</li>
                <li>±0.0</li>
                <li>'0' 文字列</li>
                <li>''</li>
                <li>null</li>
                <li>[]　空の配列</li>
            </ul>
            <p>※これ以外は全て true</p>
        </li>
        <li>
            <h3>比較演算子</h3>
            <pre>
                >= 〜以上
                <= 〜以下
                > 〜より大きい
                < 〜より小さい
                === 〜と等しい
                !== 〜と等しくない
            </pre>
        </li>
        <li>
            <h3>論理演算子</h3>
            <ul>
                <li>&& : and なおかつ</li>
                <li>|| : or もしくは</li>
                <li>! : 〜ではない</li>
            </ul>
        </li>
        <li>
            <h3>switch文</h3>
            <pre>
                $signal = 'green';

                switch($signal) {
                    case 'red':
                        echo 'Stop!' . PHP_EOL;
                        break;
                    case 'yellow':
                        echo 'Caution!' . PHP_EOL;
                        break;
                    case 'blur':
                    case 'green':
                        echo 'Go!' . PHP_EOL;
                        break;
                        
                    default:
                        echo 'Wrong signal!' . PHP_EOL;
                        break;

                }
                // Go!
            </pre>
            <p>セミコロン不要</p>
            <p>※ break 忘れに注意　出てくるまで表示される</p>
        </li>
        <li>
            <h3>ループ</h3>
            <h4>for</h4>
            <pre>
                for ($i=1; $i < 5; $i++) { 
                    // echo 'Hello' . PHP_EOL;
                    echo "$i - Hello" . PHP_EOL;
                }
            </pre>
            <h4>while</h4>
            <pre>
                $hp = 100;
                while ($hp > 0) {
                    echo "Your HP: $hp" . PHP_EOL;
                    $hp -= 15;<span class="red">// 書き忘れると無限ループに！</span>
                }
                ※条件が満たされない場合は一回も実行されない
            </pre>
            <h4>do while</h4>
            一回だけは実行したい場合
            <pre>
                $hp = -50;
                do {
                    echo "Your HP: $hp" . PHP_EOL;
                    $hp -= 15;
                } while($hp > 0);
            </pre>
            <p>セミコロン不要</p>
            <h4>for while で特定の回だけスキップ</h4>
            <p>スキップ・ブレイク</p>
            <pre>
                for ($i=1; $i < 10; $i++) { 
                    // if ($i === 4) { // 4
                    if ($i % 3 === 0) { // 3の倍数
                        <span class="red">continue;// スキップ</span>
                    }
                    if ($i === 7) {
                        <span class="red">break;// ループを抜ける</span>
                    }
                    echo $i . PHP_EOL;
                }
                // 1 2 4 5
            </pre>
        </li>
        <li>
            <h3>関数</h3>
            <h4>引数</h4>
            <pre>
                function showAd($message = 'Ad') { // 仮引数 = 'デフォルト値'
                    echo "------------------" . PHP_EOL;
                    echo "--- $message ---" . PHP_EOL;
                    echo "------------------" . PHP_EOL;
                }
                showAd('Header Ad');// 実引数
                echo "Tom is great!" . PHP_EOL;
                echo "Bob is great!" . PHP_EOL;
                showAd();
                echo "Steve is great!" . PHP_EOL;
                echo "Bob is great!" . PHP_EOL;
                showAd('Footer Ad');
            </pre>
            <h4>return</h4>
            <pre>
                function sum($a, $b, $c) {
                    // echo $a + $b + $c . PHP_EOL;
                    // 値を更に加工するには return (その時点で値が戻され、処理が終了する)
                    <span class="red">return</span> $a + $b + $c;
                }
                // sum(100, 200, 300); // 600
                // sum(300, 400, 500); // 1200
                
                echo sum(100, 200, 300) + sum(300, 400, 500) . PHP_EOL; // 1800
            </pre>
            <h4>スコープ</h4>
            <pre>
                $rate = 1.1;
                function sum($a, $b, $c) {
                    <span class="red">global</span> $rate; // <span class="red">関数外で定義された変数を使える宣言</span>　（分かりづらくなる）
                    return ($a + $b + $c) * $rate;
                }
                echo sum(100, 200, 300) + sum(300, 400, 500) . PHP_EOL; // 1980
            </pre>
            <pre>
                $rate = 1.1; // <span class="red">グローバルスコープ</span>
                function sum($a, $b, $c) {
                    $rate = <span class="red">1.08</span>; // <span class="red">ローカルスコープ</span>
                    return ($a + $b + $c) * $rate;
                }    
                echo sum(100, 200, 300) + sum(300, 400, 500) . PHP_EOL; //<span class="red">ローカルスコープ1.08が使われる</span>ので、 1944

            </pre>
            <h4>無名関数</h4>
            <p>無名関数(クロージャー)　<span class="red">変数に代入する場合はセミコロンあり</span></p>
            <p>無名関数は関数自体を別の関数の引数にして渡す事ができる</p>
            <pre>
                $sumb = function ($a, $b, $c) {
                    return $a + $b + $c;
                };
                echo <span class="red">$</span>sumb(500, 500, 1000) . PHP_EOL;
            </pre>
            <h4>条件演算子</h4>
            <p>条件演算子 <span class="red">条件？true値 : false値;</span></p>
            <pre>
                function sumB($a, $b, $c) {
                    $total = $a + $b + $c;
                    // if ($total < 0) {
                    //     return 0;
                    // } else {
                    //     return $total;
                    // }
                    <span class="red">return $total < 0 ? 0 : $total;</span>
                }
                echo sumB(100, 300, 500) . PHP_EOL; // 900
                echo sumB(-1000, 300, 500) . PHP_EOL; // 0
            </pre>
            <h4>引数の型付け</h4>
            <p>引数の型を指定</p>
            <ul>
                <li><span class="red">引数の前に型を指定</span>　弱い型付け '4' > 4にしてしまう</li>
                <li>ファイルの文頭に　<span class="red">declare(strict_types=1);</span> あいまいな変換をしない　強い型付け　（jsの　use strict の様な感じ？）
                </li>
                <li><span class="red">void 返り値が存在しない事を宣言</span></li>
            </ul>
            <pre>
                function showInfo (<span class="red">string</span> $name, <span class="red">int</span> $score) <span class="red">: void</span> // <span class="red">返り値も型を指定できる</span>　返り値がない場合 <span class="red">void</span>
                {
                    echo $name . ': ' . $score . PHP_EOL;
                }
                showInfo('taguchi' , 40);
                // showInfo('taguchi' , 'dot');
                // showInfo('taguchi' , '4');
            </pre>
            <h4>nullを返す</h4>
            <ul>
                <li>型の前に <span class="red">?</span> をつけると選択肢にnullが入る</li>
                <li>現在のPHPでは、null以外の条件はつけれない stringかintかはムリ</li>
            </ul>
            <pre>
                function getAward(<span class="red">?</span>int $score): <span class="red">?</span>string // 型の前に ? をつけると、<span class="red">null か ○○ か という意味になる</span>
                {
                    return $score >= 100 ? 'Gold Medal' : null;
                }
                echo getAward(150) . PHP_EOL;
                echo getAward(40) . PHP_EOL;
                echo getAward(null) . PHP_EOL;
            </pre>
        </li>
        <li>
            <h3>配列</h3>
            <pre>
                $scores = [
                    90,
                    40,
                    100,
                ];
                $scores[1] = 60; // 再代入
                echo $scores[1] . PHP_EOL; // 40 → 60

                echo $scores . PHP_EOL;
                // Array
            </pre>
            <h4>var_dump() print_r()</h4>
            <pre>
                <span class="red">var_dump</span>($scores);
                // array(3) {
                //   [0]=>
                //   int(90)
                //   [1]=>
                //   int(60)
                //   [2]=>
                //   int(100)
                // }

                <span class="red">print_r</span>($scores);
                // Array
                // (
                //     [0] => 90
                //     [1] => 60
                //     [2] => 100
                // )
            </pre>
            <h4>キーを設定</h4>
            <pre>
                $eachScores = [
                    <span class="red">'tagichi' =></span> 90,
                    <span class="red">'f-koji'  =></span> 40,
                    <span class="red">'kikyo'   =></span> 100,
                ];
                var_dump($eachScores);
                // array(3) {
                //     ["tagichi"]=>
                //     int(90)
                //     ["f-koji"]=>
                //     int(40)
                //     ["kikyo"]=>
                //     int(100)
                //   }
                print_r($eachScores);
                //   Array
                //   (
                //       [tagichi] => 90
                //       [f-koji] => 40
                //       [kikyo] => 100
                //   )
                echo <span class="red">$eachScores['kikyo']</span>. PHP_EOL;
            </pre>
            <h4>foreach</h4>
            <pre>
                <span class="red">foreach</span> ($eachScores <span class="red">as $value</span>) {
                    echo $value . PHP_EOL;
                }
                // 90
                // 40
                // 100
                <span class="red">foreach</span> ($eachScores <span class="red">as $key => $value</span>) {
                    echo $key . ' - ' . $value . PHP_EOL;
                }
                // tagichi - 90
                // f-koji - 40
                // kikyo - 100
            </pre>
            <p>※　$key $value　等の引数は好きな文字に変更可能</p>
            <h4>配列の中の配列</h4>
            <p>jsスプレット構文のような事ができる</p>
            <p><span class="red">PHP ver.7.4以上</span></p>
            <pre>
                $score1 = [
                55,
                72,
                ];
                $score2 = [
                90,
                40,
                <span class="red">...</span>$score1,
                100,
                ];
                print_r($score2);
            </pre>
            <p>配列の中に文字列・配列が入れられる</p>
            <pre>
                $score1 = [
                55,
                72,
                'perfect',
                [90, 42, 88],
                ];
                // 88にアクセス $scores1<span class="red">[3][2]</span>
            </pre>
            <h4>配列の関数　可変長引数</h4>
            <pre>
                // function sum($a, $b, $c) {
                //     return $a + $b + $c;
                // }

                ↓

                function sum(<span class="red">...$numbers</span>) {
                    <span class="red">
                        $total = 0;
                        foreach($numbers as $number) {
                            $total += $number;
                        }
                        return $total;
                    </span>
                }
                echo sum(1, 3, 5) . PHP_EOL; // 9
                echo sum(1, 3, 5, 6) . PHP_EOL; // 15
            </pre>
            <h4>複数の返り値を受け取る</h4>
            <pre>
                function getStats(...$numbers) {
                    $total = 0;
                    foreach($numbers as $number) {
                        $total += $number;
                    }
                    return [$total, $total / <span class="red">count</span>($numbers)];
                    // <span class="red">配列の個数 count($***) jsの.length</span>
                }
                print_r(getStats(1, 3, 5));// 合計：9 平均：3

                #変数に一気に代入 list()

                <span class="red">list</span>($sum, $average) = getStats(1, 3, 5);
                [$sum, $average] = getStats(1, 3, 5);
                echo $sum . PHP_EOL; // 9
                echo $average . PHP_EOL; // 3
            </pre>
        </li>
    </ul>
    <!-- <h2>詳解PHP ビルトイン関数編</h2> -->
    <h2>詳解PHP 【ビルトイン関数】</h2>
    <ul>
        <li>
            <h3>ビルトイン関数　一部</h3>
            <p>PHPが最初から用意してくれてる関数(組み込み関数)</p>
            <ul>
                <li>strlen('hello') // 5</li>
                <li>number_format(523350)</li>
                <li>shuffle([1, 2, 3, 4, 5]) . PHP_EOL; // シャッフル</li>
                <li>array_unique([1, 1, 4, 4, 2]) . PHP_EOL; // 1 4 2 重複を取り除く</li>
            </ul>
            <a href="https://www.php.net/">公式</a>
            <p>英語しか検索できないので、おすすめはGoogle検索で 「文字列　関数　site:php.net」</p>
        </li>
        <h2>文字列系</h2>
        <li>
            <h3>sprintf() 文字列をフォーマットに従って表示</h3>
            <h3>printf() フォーマットに従って表示</h3>
            <p>表示の設定 文字列：<span class="red">%s　整数：%d　浮動小数点数：%f</span></p>
            <pre>
        $name = 'Apple';
        $score = 32.246;

        $info = "[$name][$score]";
        echo $info . PHP_EOL; // [Apple][32.246]

        $info = <span class="red">sprintf</span>("[%15s][%10.2f]", $name, $score);
        echo $info . PHP_EOL;// [          Apple]15文字に収める　[     32.25]10文字 小数点以下２

        $info = sprintf("[%-15s][%010.2f]", $name, $score);// [          Apple]15文字に収める　[     32.25]10文字 小数点以下２
        echo $info . PHP_EOL;// [Apple          ]先頭に　[0000032.25]空欄を0で埋める

        #printf 単にフォーマットに従って表示
        <span class="red">printf</span>("[%-15s][%010.2f]" . PHP_EOL, $name, $score);
    </pre>
        </li>
        <li>
            <h3>strlen() 文字数を調べる</h3>
            <h3>trim() 空白・改行を除いて数える</h3>
            <h3>strpos() ある値が何文字目にヒットするか(0からスタート)</h3>
            <h3>str_replace(対象文字, 置換文字, 値) 置換</h3>

            <pre>
                # strlen() 文字数を調べる
                $input = 'dot_taguchi';
                echo <span class="red">strlen</span>($input) . PHP_EOL; // 11
                $input = ' dot_taguchi   ';
                echo strlen($input) . PHP_EOL; // 15
                
                # trim() 空白・改行を除いて数える
                $input = <span class="red">trim</span>($input);
                echo strlen($input) . PHP_EOL; // 11
                
                # strpos() ある値が何文字目にヒットするか(0からスタート)
                echo <span class="red">strpos</span>($input, '_') . PHP_EOL; // 3
                
                # str_replace(対象文字, 置換文字, 値) 置換
                $input = <span class="red">str_replace</span>('_', '^', $input);
                echo $input . PHP_EOL;// dot^taguchi%
            </pre>
        </li>
        <li>
            <h3>mb_***() 日本語の場合 マルチバイト</h3>
            <pre>
                $ja = 'こんにちは ';
                $ja = trim($ja);
                
                echo strlen($ja) . PHP_EOL;// 5 > 15
                echo <span class="red">mb_</span>strlen($ja) . PHP_EOL;// 5
                
                echo strpos($ja, 'に') . PHP_EOL;// 2 > 6
                echo <span class="red">mb_</span>strpos($ja, 'に') . PHP_EOL;// 2
                
                $ja = str_replace('にち', 'ばん', $ja);
                echo $ja . PHP_EOL;// こんばんは
            </pre>
        </li>
        <li>
            <h3>固定長データ substr(文字列, 位置, 桁数)</h3>
            <h3>substr_replace(文字列, 置換文字, 位置, 桁数)</h3>
            <pre>
                $itemId = '20220613Item-A  1200';
                $date = <span class="red">substr</span>($itemId, 0, 8);
                $product = substr($itemId, 8, 8);
                // $amount = substr($itemId, 16, 4);
                $amount = substr($itemId, 16);// 最後までの桁数は省略可能
                
                echo $date . PHP_EOL;// 20220613
                echo $product . PHP_EOL;// Item-A__
                echo number_format($amount) . PHP_EOL;// 1,200
                
                $itemId = <span class="red">substr_replace</span>($itemId, 'Item-B  ', 8, 8);
                echo $itemId . PHP_EOL;// Item-B__
            </pre>
        </li>
        <li>
            <h3>文字列を検索・置換 preg_match() preg_match_all() preg_replace()</h3>
            <pre>
                $input = 'Call us at 03-3001-1256 or 03-3015-3222';
                $pattern = '/\d{2}-\d{4}-\d{4}/';
                
                <span class="red">preg_match</span>($pattern, $input, $matches);
                print_r($matches);// 最初に見つかったパターンのみ配列で表示
                <span class="red">preg_match_all</span>($pattern, $input, $matches);
                print_r($matches);// 見つかった全てのパターンを配列で表示
                
                $input = <span class="red">preg_replace</span>($pattern, '**-****-****', $input);
                echo $input . PHP_EOL;// Call us at **-****-**** or **-****-****
            </pre>
        </li>
        <li>
            <h3>文字列と配列を交換</h3>
            <h3>implode(区切り文字, 値)　配列 ＞ 文字</h3>
            <h3>explode(区切り文字, 値)　文字 ＞ 配列</h3>
            <pre>
                $d = [2022, 06, 13];
                echo "$d[0]-$d[1]-$d[2]" . PHP_EOL; // 2022-06-13
                echo <span class="red">implode</span>('-', $d) . PHP_EOL; // 2022-06-13

                $t = '17:32:45';
                print_r(<span class="red">explode</span>(':', $t));
            </pre>
        </li>
        <h2>数値系</h2>
        <li>
            <h3>小数点の扱い</h3>
            <pre>
                $n = 5.6283;
                echo <span class="red">ceil</span>($n) . PHP_EOL; //切り上げ 6
                echo <span class="red">floor</span>($n) . PHP_EOL; //切り捨て 5
                echo <span class="red">round</span>($n) . PHP_EOL; //四捨五入 6
                echo <span class="red">round</span>($n, 2) . PHP_EOL; //小数点以下２桁で四捨五入 5.63

                echo <span class="red">mt_ran</span>d(1, 6) . PHP_EOL; // 1-6のランダムな整数値を作成

                echo <span class="red">max</span>(3, 9, 4) . PHP_EOL; //最大値 9
                echo <span class="red">min</span>(3, 9, 4) . PHP_EOL; //最小値 3
            </pre>
            <h3>関数ではないけど　便利な定数</h3>
            <pre>
                echo <span class="red">M_PI</span> . PHP_EOL; // 円周率 3.14159...
                echo <span class="red">M_SQRT2</span> . PHP_EOL; // 2の平方根 1.41421...
            </pre>
        </li>
        <h2>配列</h2>
        <li>
            <h3>array_unshift() 先頭に要素を追加</h3>
            <h3>array_push() 末尾に要素を追加</h3>
            <h3>array_shift() 先頭の要素を削除</h3>
            <h3>array_pop() 末尾の要素を削除</h3>
            <p>★破壊的メソッド</p>
            <pre>
                $scores = [30, 40, 50];
                print_r($scores);

                <span class="red">array_unshift</span>($scores, 10, 20);
                <span class="red">array_push</span>($scores, 60, 70);
                $scores[] = 80; // 1つだけ末尾に追加
                print_r($scores); // 10 20 30 40 50 60 70 80

                <span class="red">array_shift</span>($scores);
                <span class="red">array_pop</span>($scores);
                print_r($scores); // 20 30 40 50 60 70
            </pre>
            <h3>array_slice(配列, 位置, 個数) 配列の一部を切り出す</h3>
            <p>★非破壊メソッド　元配列を変更しない</p>
            <pre>
                $scores = [30, 40, 50, 60, 70];
                // $partial = <span class="red">array_slice</span>($scores, 2, 3); // 最後までの場合は個数を省略可能
                $partial = <span class="red">array_slice</span>($scores, 2); // 同じ意味
                print_r($scores); // 元のまま
                print_r($partial); // 50 60 70
            
                $partial = <span class="red">array_slice</span>($scores, -2); // 最後から2番目
                print_r($partial); // 60 70
            </pre>
            <h3>array_splice(配列, 位置, 個数) を削除</h3>
            <p>★破壊的メソッド</p>
            <h3>array_splice(配列, 削除位置, 削除個数, 挿入要素)</h3>
            <pre>
                $scores = [30, 40, 50, 60, 70, 80];
            
                <span class="red">array_splice</span>($scores, 2, 2);
                print_r($scores); // 50 60　を削除して、30 40 70 80
            
                <span class="red">array_splice</span>($scores, 2, 1, 100);
                print_r($scores); // 70　を削除して、100を入れる　30 40 100 80
            
                <span class="red">array_splice</span>($scores, 2, 0, 99);
                print_r($scores); // 100を削除せず、99を入れる　30 40 99 100 80
            </pre>
            <h3>sort() rsort() 小さき順　大きい順 </h3>
            <h3>shuffle() シャッフル</h3>
            <h3>array_rand(値, 数) キーを返す</h3>
            <pre>
                $scores = [40, 50, 20, 30];
                # sort() rsort() 小さき順　大きい順 
                <span class="red">sort</span>($scores);
                print_r($scores); // 20 30 40 50

                <span class="red">rsort</span>($scores);
                print_r($scores); // 50 40 30 20

                # shuffle() ★破壊
                <span class="red">shuffle</span>($scores);
                print_r($scores); // シャッフル

                # array_rand(値, 数) キーを返す　★非破壊
                // 新しい配列を返すので変数で受ける
                $picked = <span class="red">array_rand</span>($scores, 2);
                print_r($picked); // ランダムに２つの値のキー
                //  値を返したければ
                echo $scores[$picked[0]] . PHP_EOL;
                echo $scores[$picked[1]] . PHP_EOL;
            </pre>
            <h3>array_fill(スタートindex,　終了index,　埋める値)</h3>
            <h3>range(スタート,　終了) 配列を作る</h3>
            <h3>array_sum() 合計値</h3>
            <pre>
                # array_fill(スタートindex,　終了index,　埋める値)
                $scores = <span class="red">array_fill</span>(0, 5, 10);
                print_r($scores); // 10 10 10 10 10

                # range(スタート,　終了) 配列を作る
                $scores = <span class="red">range</span>(1, 10);
                print_r($scores); // 1 ~ 10
                $scores = <span class="red">range</span>(1, 10, 2);
                print_r($scores); // 1 3 5 7 9

                echo <span class="red">array_sum</span>($scores) . PHP_EOL; // 合計値 25
                echo max($scores) . PHP_EOL; // 9
                echo min($scores) . PHP_EOL; // 1
                echo array_sum($scores) / count($scores) . PHP_EOL; // 平均　5
            </pre>
            <h3>array_merge(配列A,配列B) 配列の結合</h3>
            <h3>array_diff(配列A,配列B) 配列Aから配列Bを引く　差異のあるAが残る</h3>
            <h3>array_intersect(配列A,配列B) 配列Aと配列Bの共通の値のみ表示</h3>
            <pre>
                $a = [3, 4, 8];
                $b = [4, 8, 12];
                // 複数の配列
                # array_merge(配列A,配列B) 配列の結合
                $merge = <span class="red">array_merge</span>($a, $b);
                // $merge = [...$a, ...$b]; // 上と同じ意味(前出)
                print_r($merge); // 3 4 8 4 8 12

                # array_diff(配列A,配列B) 配列Aから配列Bを引く　差異のあるAが残る
                $diff1 = <span class="red">array_diff</span>($a, $b);
                print_r($diff1); // 3
                $diff2 = array_diff($b, $a);
                print_r($diff2); // 12

                # array_intersect(配列A,配列B) 配列Aと配列Bの共通の値のみ表示
                $common = <span class="red">array_intersect</span>($a, $b);
                print_r($common); // 4 8
            </pre>
            <h3>array_map($fn, $a) それぞれの値に関数を通す</h3>
            <pre>
                $prices = [100, 200, 300];
                // 10%の税込みに変更
                $newPrices = <span class="red">array_map</span>(
                    function ($n) {
                        return $n * 1.1;
                    },
                    // fn ($n) => $n * 1.1, // アロー関数
                    $prices
                );
                print_r($newPrices); // 110 220 330
            </pre>
            <h3>array_filter($a, $fn) // それぞれの値にテストをし true だった値のみを返す</h3>
            <pre>
                $numbers = range(1, 10); // 1 ~ 10
                // 偶数のみ
                $evenNumbers = <span class="red">array_filter</span>(
                    $numbers,
                    function ($n) {
                        // if ($n % 2 === 0) {
                        //     return true;
                        // } else {
                        //     return false;
                        // } // 条件のみ返しても同じ事
                        return $n % 2 === 0;
                    }
                );
                // アロー関数
                // $evenNumbers = <span class="red">array_filter</span>(
                //     $numbers,
                //     fn($n) => $n % 2 === 0
                // );
                print_r($evenNumbers); // 2 4 6 8 10
            </pre>
            <h3>配列のキー、値を操作</h3>
            <pre>
                <h3># array_keys() array_values()</h3>
                $scores = [
                    'taguchi' => 80,
                    'hayashi' => 70,
                    'kikuchi' => 60,
                ];
                $keys = <span class="red">array_keys</span>($scores);
                print_r($keys); // taguchi ...
                $valurs = <span class="red">array_values</span>($scores);
                print_r($valurs); // 80 70 ...

                <h3># array_key_exists　キーに含まれるか</h3>
                if (<span class="red">array_key_exists</span>('taguchi', $scores)) {
                    echo 'taguchi is here!' . PHP_EOL;
                }
                <h3># in_array　配列に含まれるか</h3>
                if (<span class="red">in_array</span>(80, $scores)) {
                    echo '80 is here!' . PHP_EOL;
                }
                <h3># array_search() 値を検索して対応するキーを返す</h3>
                echo <span class="red">array_search</span>(70, $scores) . PHP_EOL; // hayashi

                # (前出の sort rsort はキーを削除して連番になる)
                // sort($scores);
                // print_r($scores);
                // rsort($scores);
                // print_r($scores);

                <h3># asort() arsort() キーを保持したまま値でソート</h3>
                <span class="red">asort</span>($scores);
                print_r($scores);
                // Array
                // (
                //     [kikuchi] => 60
                //     [hayashi] => 70
                //     [taguchi] => 80
                // )
                <span class="red">arsort</span>($scores);
                print_r($scores);
                // Array
                // (
                //     [taguchi] => 80
                //     [hayashi] => 70
                //     [kikuchi] => 60
                // )

                <h3># ksort() krsort() キーでソートしたい</h3>
                <span class="red">ksort</span>($scores);
                print_r($scores);
                // Array
                // (
                //     [hayashi] => 70
                //     [kikuchi] => 60
                //     [taguchi] => 80
                // )
            </pre>
            <h3>複雑な配列でソート</h3>
            <pre>
                $data = [
                    ['name' => 'taguchi', 'score' => 80],
                    ['name' => 'kikuchi', 'score' => 60],
                    ['name' => 'hayashi', 'score' => 70],
                    ['name' => 'tamachi', 'score' => 60],
                ];
                <h3># usort() 破壊的？　一つの項目でのみソート(比較)可能</h3>
                <span class="red">usort</span>(
                    $data,
                    function ($a, $b) {
                        if ($a['score'] === $b['score']) {
                            return 0;
                        }
                        return $a['score'] > $b['score'] ? 1 : -1;
                    }
                );
                print_r($data);
            </pre>
            <h3>複数の条件のソート</h3>
            <pre>
                $data = [
                    ['name' => 'taguchi', 'score' => 80],
                    ['name' => 'kikuchi', 'score' => 60],
                    ['name' => 'hayashi', 'score' => 70],
                    ['name' => 'tamachi', 'score' => 60],
                ];
                <h3># array_multisort()　複数の項目でソート(比較)可能　破壊的？</h3>
                // scoreで並び替えた後に、nameで並び替える
                // <span>array_multisort</span>($scores, $names, $data)

                # array_column()
                $scores = array_column($data, 'score');
                $names = array_column($data, 'name');
                // print_r($scores);
                // print_r($names);

                // <span class="red">array_multisort</span>(
                //     $scores,
                //     $names,
                //     $data
                // );
                // print_r($data); // 菊池　田町　林　田口

                <span class="red">array_multisort</span>(
                    $scores, SORT_DESC, SORT_NUMERIC, // 大きい順　数値
                    $names, SORT_DESC, SORT_STRING, // 降順　文字列
                    $data
                );
                print_r($data); // 田口　林　田町　菊池
            </pre>
        </li>

        <h2>ファイル管理</h2>
        <li>
            <h3>ファイルを操作</h3>
            <pre>
                <h3># fopen() ファイルを操作</h3>
                <h3># fwrite()</h3>
                <h3># fclose()</h3>

                <h3># ファイルの新規作成　用意</h3>
                // names.txt　がなければ新しく作る ファイルポインタ(特殊な変数)を返すので $fp で受け取る
                //書き込みモード write の w

                // $fp = fopen('names.txt', 'w');
                // fwrite($fp, "taro\n");
                // fclose($fp);

                <h3># Unixコマンド</h3>
                // cat 中身の確認
                // 書き込みモード　実行する度に追加される訳ではなく、上書きされる

                <h3># テキストを追加</h3>
                // 書き込みモード　append の a

                // $fp = fopen('names.txt', 'a');
                // fwrite($fp, "jiro\n");
                // fwrite($fp, "saburo\n");
                // fclose($fp); // 実は自動で閉じるので省略可能だけど、分かりやすい

                <h3>#テキストを読み込む r</h3>
                // fread() サイズを指定して一気に読み込む
                // filesize() ファイルサイズを調べる

                // $fp = fopen('names.txt', 'r');
                // $contents = fread($fp, filesize('names.txt'));
                // fclose($fp);

                // echo $contents;

                <h3># 一行ずつ読み込む</h3>

                // $fp = fopen('names.txt', 'r');
                // while (($line = fgets($fp)) !== false) {
                //     echo $line;
                // }
                // fclose($fp);


                <h3># 新規作成</h3>
                // $contents = "taro\njiro\nsaburo\n";
                // file_put_contents('names.txt', $contents);

                <h3># 読み込み</h3>
                // $contents = file_get_contents('names.txt');
                // echo $contents;

                <h3># 一行ずつ配列の要素で読み込む</h3>
                // $lines = file('names.txt');
                // $lines = file('names.txt', FILE_IGNORE_NEW_LINES);// 末尾の改行を無視
                // var_dump($lines);
            </pre>
            <h3>ディレクトリの操作</h3>
            <pre>
                // file_put_contents('data/taro.txt', "taro\n");
                // file_put_contents('data/jiro.txt', "jiro\n");

                // $dp = opendir('data');
                // while (($item = readdir($dp)) !== false) {
                //     if ($item === '.' || $item === '..') {
                //         continue;
                //     }
                //     echo $item . PHP_EOL;
                // }

                // 上と同じ

                // foreach (glob('data/*.txt') as $item) {
                //     // echo $item . PHP_EOL; // data/***.txt
                //     echo basename($item) . PHP_EOL; // ***.txt
                // }
            </pre>
            <h3>ファイルのチェック</h3>
            <pre>
                # file_exists() ディレクトリ・ファイルが存在するかどうか
                if (file_exists('data')) {
                    echo 'data exists!' . PHP_EOL;
                }
                # is_writable() 書き込み可能か
                if (is_writable('data/taro.txt')) {
                    echo 'taro is writable!' . PHP_EOL;
                }
                # is_readable() 読み込み可能か
                if (is_readable('data/taro.txt')) {
                    echo 'taro is readable!' . PHP_EOL;
                }
                # exit 処理を止める
                if (!file_exists('data/saburo.txt')) {
                    echo 'Saburo not here!' . PHP_EOL;
                    exit; // 処理が止まる
                }
                echo 'end' . PHP_EOL;
            </pre>
        </li>
        <h2>日付の計算</h2>
        <li>
            <pre>
                # 日付 UNIX タイムスタンプ 1970/01/01 00:00:00 GMT
                // time() ↑からの経過秒数
                // 一日分　+24*60*60 +24h*60m*60s

                # data(フォーマット, UNIXタイムスタンプ)　見やすい形式に戻す
                // PHPが稼働しているマシンのタイムゾーンを考慮してローカルタイムになる

                # data('Y-m-d', time());
                // Y 年を4桁で
                // m 月を2桁で
                // d 日を2桁で

                # data('H:i:s', time());
                // 時:分:秒 を2桁ずつ

                # data('l', time());
                // 英語の曜日

                # data('W', time());
                // 一年の内の第何周目か

                echo time() . PHP_EOL;// 1655139737
                // echo date('Y-m-d l', time()) . PHP_EOL; // 2022-06-13 Monday
                echo date('Y-m-d l') . PHP_EOL; // 単に現在日時を表示する場合は time() を省略可

                // 特定日時のタイムスタンプを計算するのは面倒
                # mktime() 引数の順番に注意　時　分　秒　月　日　年
                echo date('Y-m-d l', mktime(0, 0, 0, 5, 1, 2000)) . PHP_EOL;// 2000-05-01 Monday

                // 日時っぽい文字列から
                echo date('Y-m-d l', strtotime('2022-06-14')) . PHP_EOL;
                echo date('Y-m-d l', strtotime('2022-06-14 +1 day')) . PHP_EOL;

                // ※ date() mktime() strtotime() 32bitのマシンでは2038年以降うまく動作しない
                // DateTimeクラス　が一般的　難しいのでまた
            </pre>
        </li>
    </ul>
    <!-- <h2>詳解PHP オブジェクト編</h2> -->
    <h2>詳解PHP 【オブジェクト編】</h2>
    <ul>
        <li>
            <h2>Class</h2>
            <pre>
                1:構造を定義する　class Post { ... }
                2:新しい値を作る　$post = new Post();
                3:オブジェクトを使う　$post->text = 'hello';
                　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　$post->likes = 0;
                　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　$post->show();
            </pre>
            <h4 class="gray">(オブジェクトを使わない場合)</h4>
            <pre class="gray">
                $posts = [];
                $posts[0] = ['text' => 'hello', 'likes' => 0];
                $posts[1] = ['text' => 'hello again', 'likes' => 0];

                print_r($posts);
                // Array
                // (
                //     [0] => Array
                //         (
                //             [text] => hello
                //             [likes] => 0
                //         )

                //     [1] => Array
                //         (
                //             [text] => hello again
                //             [likes] => 0
                //         )

                // )
                表示する関数
                function show($post)
                {
                    printf('%s (%d)' . PHP_EOL, $post['text'], $post['likes']);
                }
                show($posts[0]); // hello (0)
                show($posts[1]); // hello again (0)
            </pre>
            <h3>classを使った場合</h3>
            <pre>
                // -> アロー演算子　$this->***

                <span class="red">// クラス</span>
                <span class="red">class P</span>ost
                {
                    <span class="red">// プロパティ</span>
                    <span class="red">public</span> $text;
                    public $likes = 0;
                    
                    <span class="red">// コンストラクタ</span>
                    // public function <span class="red">__construct</span>(<span class="blue">$textFromNew</span>, $likesFromNew)
                    // {
                    //    <span class="red">$this-></span>text = <span class="blue">$textFromNew</span>;
                    //    $this->likes = $likesFromNew;
                    // }
                    <span class="blue">// 慣れたらプロパティと同じ名前の方が良い</span>
                    public function __construct(<span class="blue">$text</span>)
                    {
                        $this->text = <span class="blue">$text</span>;
                    }

                    <span class="red">// メソッド</span>
                    public <span class="red">function show()</span>
                    {
                        printf('%s (%d)' . PHP_EOL, $this->text, $this->likes);
                    }
                }
                $posts = [];

                <span class="gray">// $posts[0] = ['text' => 'hello', 'likes' => 0];</span>
                // $posts[0] = new Post();// インスタンス ()なくてもOK
                // $posts[0]->text = 'hello';
                // $posts[0]->likes = 0;
                $posts[0] = <span class="red">new P</span>ost(<span class="blue">'hello'</span>);<span class="red">// インスタンス</span>

                // $posts[1] = new Post();
                // $posts[1]->text = 'hello again';
                // $posts[1]->likes = 0;
                $posts[1] = new Post('hello again');

                <span class="gray">// show($posts[0]); // hello (0)</span>
                <span class="red">$posts[0]->show();</span> // hello (0)
                $posts[1]->show(); // hello again (0)
            </pre>
            <h2>アクセス修飾子</h2>
            <pre>
                // クラス
                class Post
                {
                    // プロパティ
                    <span class="red">public</span> $text; // <span class="red">アクセス修飾子 public　クラス外からもアクセス可能</span>
                    <span class="red">private</span> $likes = 0; // <span class="red">private このクラスの中でしか使えない</span>
                    // <span class="red">カプセル化：アクセス修飾子を付けて、何が出来るか出来ないかを明確にする事</span>
                    
                    // コンストラクタ
                    public function __construct($text)
                    {
                        $this->text = $text;
                    }

                    // メソッド
                    public function show()
                    {
                        printf('%s (%d)' . PHP_EOL, $this->text, $this->likes);
                    }
                    public function <span class="red">like()</span>
                    {
                        $this->likes++;

                        if ($this->likes > 100) {
                            $this->likes = 100;
                        }
                    }
                }
                $posts = [];

                $posts[0] = new Post('hello');
                $posts[1] = new Post('hello again');

                // $posts[0]->likes++; // <span class="red">privateにしたので不可</span>
                // $posts[0]->likes = -100;

                $posts[0]-><span class="red">like()</span>;

                $posts[0]->show(); // hello (<span class="red">1</span>)
                $posts[1]->show(); // hello again (0)
            </pre>
            <h2>型付け</h2>
            <p>PHPverで使えない?</p>
            <pre>
                <span class="red">declare(strict_types=1);// 強い型付け</span>

                class Post
                {
                private <span class="red">string</span> $text; // <span class="red">弱い型付け</span>

                public function __construct(<span class="red">string</span> $text) // <span class="red">弱い型付け</span>
                {
                    $this->text = $text;
                }

                public function show()
                {
                    printf('%s' . PHP_EOL, $this->text);
                }
                }

                $posts = [];
                // $posts[0] = new Post('hello');
                $posts[0] = new Post(5);// 弱い型付けは5を文字列にしてしまう
                $posts[1] = new Post('hello again');

                $posts[0]->show();
                $posts[1]->show();
            </pre>
            <h2>static const クラスプロパティ・クラスメソッド・オブジェクト定数</h2>
            <p>クラスに直接紐付け</p>
            <pre>
                class Post
                {
                    private $text;
                
                    <span class="red">// static クラス自身のプロパティやメソッドを設定 </span>(アクセス修飾子の後)
                    <span class="red">// self::$***　でアクセス</span>
                    <span class="red">// const 定数は大文字 $なし </span>(アクセス修飾子の後)
                    private <span class="red">static</span> $count = 0; <span class="blue">// クラスプロパティ　変数</span>
                    // private const <span class="red">VERSION</span> = 0.1; <span class="blue">//オブジェクト定数 大文字</span>
                    <span class="red">public</span> const VERSION = 0.1; //定数 の場合は変更される心配がないので public でも問題なし

                    public function __construct($text)
                    {
                        $this->text = $text;
                        <span class="red">self::$</span>count++;
                    }
                    
                    public function show()
                    {
                        printf('%s' . PHP_EOL, $this->text);
                    }
                    // classに紐付いたメソッド　static function
                    public <span class="red">static</span> function showInfo() { <span class="blue">// クラスメソッド</span>
                        printf('Count: %d' . PHP_EOL, self::$count);
                        printf('Version: %.1f' . PHP_EOL, self::VERSION);
                    }
                }
                $posts = [];
                
                $posts[0] = new Post('hello');
                $posts[1] = new Post('hello again');
                
                $posts[0]->show(); // hello
                $posts[1]->show(); // hello again
                
                // classから直接実行
                <span class="red">Post::showInfo();</span>
                // Count:2 // インスタンスを作った数
                // Version: 0.1 // VERSION
                echo <span class="red">Post::VERSION</span> . PHP_EOL; // 0.1　<span class="red">publicなので直接呼び出せる</span>
            </pre>
            <h2>クラスの継承</h2>
            <h3>クラスを継承する</h3>
            <pre>
                class Post <span class="blue">// 親クラス Superクラス</span>
                {
                    private $text;

                    public function __construct($text)
                    {
                        $this->text = $text;
                    }
                    
                    public function show()
                    {
                        printf('%s' . PHP_EOL, $this->text);
                    }
                }
                // 新しいクラスを作成
                // extends Post で Post を継承
                //SponsoredPostクラス が Postクラス を継承した
                class SponsoredPost <span class="red">extends</span> Post <span class="blue">// 子クラス Subクラス</span>
                {
                    private $sponsor;

                    public function __construct($text, $sponsor)
                    {
                        // 親クラスのコンストラクタにある $text を使うので
                        <span class="red">parent::__construct($text);</span>
                        $this->sponsor = $sponsor; // 独自のプロパティ
                    }
                    public function <span class="red">showSponsor()</span>
                    {
                        printf('%s' . PHP_EOL, $this->sponsor);
                    }
                }
                $posts = [];

                $posts[0] = new Post('hello'); // hello
                $posts[1] = new Post('hello again'); // hello again
                // $posts[2] = new SponsoredPost('hello hello'); // SponsoredPost の中身が空でも表示される hello hello
                $posts[2] = new SponsoredPost('hello hello', 'dotinstall');

                $posts[0]->show(); // hello
                $posts[1]->show(); // hello again
                $posts[2]->show(); // hello hello
                <span class="red">$posts[2]->showSponsor();</span> // dotinstall

            </pre>
            <h3>メソッドをover ride</h3>
            <p>親クラスと同名のメソッドを再定義する事</p>
            <pre>
                class Post
                {
                    // private $text; <span class="blue">// privateのままだと他のクラスで使えない</span>
                    <span class="red">protected</span> $text; <span class="red">// protected このクラスと継承したクラスでのみ使用可能</span>

                    public function __construct($text)
                    {
                        $this->text = $text;
                    }
                    
                    // final public function show() // final overrideして欲しくないメソッドをロック(アクセス修飾子の前)
                    public function <span class="blue">show()</span>
                    {
                        printf('%s' . PHP_EOL, $this->text);
                        // 親クラスで $text は private
                    }
                }

                class SponsoredPost extends Post
                {
                    private $sponsor;

                    public function __construct($text, $sponsor)
                    {
                        parent::__construct($text);
                        $this->sponsor = $sponsor;
                    }
                    public function showSponsor()
                    {
                        printf('%s' . PHP_EOL, $this->sponsor);
                    }
                    <span class="red">// メソッドのoverride 親クラスと同名のメソッドを再定義</span>
                    public function <span class="blue">show()</span>
                    {
                        printf('%s by %s' . PHP_EOL, $this->text, $this->sponsor);
                    }
                }
                $posts = [];

                $posts[0] = new Post('hello'); // hello
                $posts[1] = new Post('hello again'); // hello again
                // $posts[2] = new SponsoredPost('hello hello');
                $posts[2] = new SponsoredPost('hello hello', 'dotinstall');

                $posts[0]->show(); // hello
                $posts[1]->show(); // hello again
                <span class="red">$posts[2]->show();</span> // hello hello > <span class="red">hello hello by dotinstall</span>
                $posts[2]->showSponsor(); // dotinstall
            </pre>
            <h3>型の継承</h3>
            <p>プロパティやメソッドの他に、<span class="red">データ型も継承している</span></p>
            <p>SponsoredPost　は　Post型としても扱える</p>
            <pre>
                class Post
                {
                    protected $text;

                    public function __construct($text)
                    {
                        $this->text = $text;
                    }
                    
                    public function show()
                    {
                        printf('%s' . PHP_EOL, $this->text);
                    }
                }

                class SponsoredPost extends Post
                {
                    private $sponsor;

                    public function __construct($text, $sponsor)
                    {
                        parent::__construct($text);
                        $this->sponsor = $sponsor;
                    }
                    
                    public function show()
                    {
                        printf('%s by %s' . PHP_EOL, $this->text, $this->sponsor);
                    }
                }
                $posts = [];

                $posts[0] = new Post('hello');
                $posts[1] = new Post('hello again');
                $posts[2] = new SponsoredPost('hello hello', 'dotinstall');

                <span class="red">// Post型の変数を受け取って処理する関数を作り、確かめる</span>
                function processPost(Post $post)<span class="red">// Post型のpostのみ受け付ける</span>
                {
                    $post->show();
                }

                foreach ($posts as $post) {
                    processPost($post);
                }
                <span class="red">// 同じ結果に。 SponsoredPostもPost型として扱えるという事</span>
                // $posts[0]->show(); // hello
                // $posts[1]->show(); // hello again
                // $posts[2]->show(); // hello hello by dotinstall

            </pre>


            <h3>レベルアップしたら</h3>
            <p>むずすぎる</p>
            <ul>
                <li>抽象クラス　抽象メソッド</li>
                <li>インターフェース</li>
                <li>トレイト</li>
                <li>外部ファイルを読み込む</li>
                <li>クラスを自動的に読み込む</li>
                <li>名前空間</li>
                <li>例外処理</li>
            </ul>
        </li>
        <li>

        </li>
    </ul>
    <!-- <h2>詳解PHP ウェブ開発編</h2> -->
    <h2>詳解PHP 【ウェブ開発編】</h2>
    <p>PCにdockerを導入し、その上でサーバーを起動</p>
    <p>サーバーとPCに、以下のファイルを置き、同期されるように設定</p>
    <ul>
        <li>work/
            <ul>
                <li>app/　ブラウザからアクセスして欲しくないファイル</li>
                <li>web/　アクセス localhost:8080</li>
            </ul>
        </li>
    </ul>



    <!-- <h2>詳解PHP データベース編</h2> -->
    <div id="toTop"><a href="#">TOP</a></div>
    <script>
        // (function (window, document) {
        const h2s = document.querySelectorAll('h2');
        const toc = document.getElementById('toc');
        const tocTitle = document.querySelector('.toc-title');

        const ul = document.createElement('ul');
        h2s.forEach((h2, i) => {
            h2.id = `h2_${i}`;
            const li = document.createElement('li');
            const a = document.createElement('a');
            a.href = `#h2_${i}`;
            a.textContent = h2.textContent;
            li.appendChild(a);
            ul.appendChild(li);
        });
        toc.append(ul);
        // })(window, document);
        // (function (window, document) {
        //     const selector = document.querySelector('.post-body');
        //     if (!selector) {
        //         return
        //     }

        //     const toc = document.createElement('details');
        //     const sum = document.createElement('summary');
        //     const list = document.createElement('ul');
        //     toc.id = 'toc';
        //     toc.open = true;
        //     sum.className = 'toc-title';
        //     sum.textContent = '目次';
        //     list.className = 'toc-container';
        //     toc.appendChild(sum);
        //     toc.appendChild(list);

        //     const headings = selector.querySelectorAll('h2, h3, h4');
        //     if (headings.length == 0) {
        //         return
        //     }
        //     headings[0].parentNode.insertBefore(toc, headings[0]);
        //     const order = [];
        //     const stack = [{ level: 1, element: list }];

        //     // 事前処理
        //     headings.forEach((heading) => {
        //         const level = parseInt(heading.tagName.substring(1))
        //         order.push(level);
        //     });

        //     headings.forEach((heading, i) => {
        //         const level = parseInt(heading.tagName.substring(1));
        //         const next = order[i + 1];
        //         const li = document.createElement('li');
        //         const a = document.createElement('a');
        //         const id = 'toc-' + (i + 1);
        //         const ul = document.createElement('ul');

        //         // 目次要素の生成
        //         a.textContent = heading.textContent;
        //         a.href = `#${id}`;
        //         li.appendChild(a);
        //         if (level < next) {
        //             li.appendChild(ul);
        //         }

        //         // リンク先の生成
        //         heading.id = id;

        //         // 階層構造の生成
        //         let parent;
        //         do {
        //             parent = stack.pop();
        //         } while (parent.level >= level);
        //         parent.element.appendChild(li);
        //         stack.push(parent);
        //         stack.push({ level: level, element: ul });
        //     });
        // }(window, document));

    </script>
</body>

</html>